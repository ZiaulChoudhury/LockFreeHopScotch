#include <iostream>
#include <atomic>
#include <thread>
#include <climits>
#include <vector>
#include <stdlib.h>
#include <time.h>
#include <sys/time.h>
#include <stdio.h>
#include <chrono>
#include <unistd.h>
#define TOTDATA 1024*1024*12
#define TotalBuckets   1024*1024*27
#define mmix(h,k) { k *= m; k ^= k >> r; k *= m; h *= m; h ^= k; }

#ifndef LFHASH_H_
#define LFHASH_H_

std::atomic<unsigned long> Buckets[TotalBuckets];
class LFHash {
public:
    std::atomic<unsigned long> TimeCounter;
    LFHash(){
    srand(time(NULL));
    substract.store(0);
    timeStamp.store(0);
    seed = rand() % LONG_MAX +1;
    for(int i=0;i<TotalBuckets + H; i++)
        Buckets[i].store(0);
    };
    ~LFHash(){};
    unsigned int TimeStamp(){
    	return timeStamp.fetch_add(1,std::memory_order_relaxed);}

    unsigned int MurmurHash2A (const void * key, int len, unsigned int tabsize)
    {

	/*unsigned int *xx = (unsigned int*)k;
	unsigned int key = *xx;
	key += ~(key << 32);
  	key ^= (key >> 22);
  	key += ~(key << 13);
  	key ^= (key >> 8);
  	key += (key << 3);
  	key ^= (key >> 15);
  	key += ~(key << 27);
  	key ^= (key >> 31);*/
  	//return key;

        const unsigned int m = 0x5bd1e995;
        const int r = 24;
        unsigned int l = len;
        const unsigned char * data = (const unsigned char *)key;
        unsigned int h = seed;
        while(len >= 4)
        {
            unsigned int k = *(unsigned int*)data;

            mmix(h,k);

            data += 4;
            len -= 4;
        }
        unsigned int t = 0;
        switch(len)
        {
            case 3: t ^= data[2] << 16; break;
            case 2: t ^= data[1] << 8; break;
            case 1: t ^= data[0]; break;
        };
        mmix(h,t);
        mmix(h,l);
        h ^= h >> 13;
        h *= m;
        h ^= h >> 15;
        return h % tabsize;
    }
    unsigned int CreateBucketEntry(unsigned int key, unsigned long *NewEntry, short int threadID)
    {
        unsigned int InitialSlot =  MurmurHash2A((const void*)&key, 4, TotalBuckets);
        unsigned long Entry = 0;
        short int header=0;
        short int STATE = 3;
        STATE<<=14;
        header|=STATE;
        header|=threadID;
        Entry|=key;
        Entry|=(0L|header)<<48;
        *NewEntry = Entry;
        return InitialSlot;

    }
    unsigned int getKey(unsigned long Entry)
    {
        long Mask = 0xFFFFFFFFFFFFL;
        return (unsigned int)(Entry & Mask);
    }
    unsigned short int getHeader(unsigned long Entry)
    {

        unsigned short int header = Entry >> 48;
        return header;
    }
    unsigned int getBucket(unsigned int index)
    {
        unsigned int StoredKey = getKey(Buckets[index].load());
        unsigned int ind = MurmurHash2A((const void*)&StoredKey, 4, TotalBuckets);
        return ind;
    }
    bool BucketInsert(unsigned int BaseBucket, unsigned int key){
    	unsigned int index;
    	short int Header;
    	unsigned int Entry = key;
    	unsigned long tag=0;
    	unsigned long _SlotEntry=0;
    	unsigned long cachedEntry;
    	#pragma GCC ivdep
    	for(int p=0;p<=H;p++){
    		index = BaseBucket + p;
    		_SlotEntry = Buckets[index].load();
    		Header = getHeader(_SlotEntry);
    		Header>>=14;
    		if(Header == 2)
    			cachedEntry = _SlotEntry;
    		if(_SlotEntry == 0)
    			if(Buckets[index].compare_exchange_strong(tag,Entry))
    				return true;
    	}
    	#pragma GCC ivdep
    	for(int p=0;p<=H;p++){
    		index = BaseBucket + p;
    		_SlotEntry = Buckets[index].load();
    		Header = getHeader(_SlotEntry);
    		Header>>=14;
    		if(Header == 2)
    			if(_SlotEntry != cachedEntry)
    				return false;
    			else
    				return Buckets[index].compare_exchange_strong(_SlotEntry,Entry);
    	}
    	printf("\n\n NEED A REHASHING OF THE HASH MAP \n\n ");
    	exit(0);
    }
    bool  add(unsigned int key)
    {
    unsigned long  Entry;
    unsigned long tag=0;
    unsigned int SlotIndex = CreateBucketEntry(key, &Entry, 0);
    unsigned int BaseBucket = SlotIndex;
    int trails=0;
    if(contains(key))
        return true;
    do
    {
        while(trails++ < ADD_RANGE && Buckets[SlotIndex].load()!=0)
            SlotIndex++;
    }while(!Buckets[SlotIndex].compare_exchange_strong(tag,Entry) && trails < ADD_RANGE);
    if(trails >= ADD_RANGE){std::cout<< " insertion failure "  << trails;exit(0);}
    if((SlotIndex - BaseBucket)> H){
        do{
            unsigned int prevSlot = SlotIndex;
            SlotIndex = this->Relocate(SlotIndex, Entry);
            if(prevSlot == SlotIndex){exit(0);}
        }while((SlotIndex - BaseBucket) > H);}

    unsigned long Exp = Buckets[SlotIndex].load();
    Buckets[SlotIndex].compare_exchange_strong(Exp,0);
    while(!BucketInsert(BaseBucket,key)){}
    return true;
    }

    unsigned int  Relocate(unsigned int Loc, long NewEntry)
    {
    unsigned int Replace = Loc - H;
    unsigned long Exp, Fin, Dest;
    unsigned int Ind=Replace;
    do{
        unsigned int BaseLoc = getBucket(Ind);
        unsigned int HopDist = (Loc - BaseLoc);
        while(HopDist >= H && Replace < Loc){
            Replace++;
            BaseLoc=getBucket(Replace);
	    printf(" R. = %d ", rand()%10000);
            HopDist = (Loc - BaseLoc);
        }
        if(HopDist > H || Replace >= Loc){ std::cout<< "\n\nRESIZE()\n\n"; exit(0); }
        Exp = Buckets[Replace].load();
        Exp = ((Exp << 2) >> 2);
        Fin = ((Exp << 2) >> 2)| (1L<<62);
        Ind = Replace+1;
    }while(!Buckets[Replace].compare_exchange_strong(Exp, Fin));

    printf("\n");
    do{
        Dest = Buckets[Loc].load();
        Dest = ((Dest << 2) >>2)| (3L<<62);
        Fin = Buckets[Replace].load();
        Fin = ((Fin<<2)>>2);
    }while(!Buckets[Loc].compare_exchange_strong(Dest, Fin));

    do{
        Exp = Buckets[Replace].load();
        Exp = ((Exp <<2 )>>2) | (1L<<62);
    }while(!Buckets[Replace].compare_exchange_strong(Exp, NewEntry));

    return Replace;
    }

    bool  contains(unsigned int key)
    {
    unsigned int  InitialSlot =  MurmurHash2A((const void*)&key, 4, TotalBuckets);
    unsigned long _SlotEntry=0;
    unsigned long _KeyEntry1=key;
    unsigned long _KeyEntry2=key;
    _KeyEntry2 = ((_KeyEntry2 << 2) >> 2)| (1L<<62);

    #pragma GCC ivdep
    for(unsigned int p=0;p<=H ; p++)
    {
        _SlotEntry = Buckets[InitialSlot+p].load();
        if(_KeyEntry1 == _SlotEntry || _SlotEntry == _KeyEntry2)
                return true;
    }
    return false;
}

bool Remove(unsigned int key)
{
	unsigned int InitialSlot =  MurmurHash2A((const void*)&key, 4, TotalBuckets);
	    unsigned long _SlotEntry=0;
	    bool rem1 = false;
	    bool rem2 = false;
	    unsigned long random;
    	    #pragma GCC ivdep
	    for(int p=0;p<=H;p++)
	    {
	        _SlotEntry=key;
	        if(Buckets[InitialSlot+p].load()==_SlotEntry){
	        	unsigned int FinalEntry = TimeStamp();
	        	FinalEntry = ((FinalEntry<<2)>>2)|(2L << 62);
	        	if(Buckets[InitialSlot+p].compare_exchange_strong(_SlotEntry,FinalEntry))
	        		rem1 = true;
	        }
	        _SlotEntry|=(1L<<62);
	        if(Buckets[InitialSlot+p].load()==_SlotEntry){
	        	unsigned int FinalEntry = TimeStamp();
	        	FinalEntry = ((FinalEntry<<2)>>2)|(2L << 62);
	        	if(Buckets[InitialSlot+p].compare_exchange_strong(_SlotEntry,FinalEntry))
	        		rem2 = true;
	        }
	        _SlotEntry = Buckets[InitialSlot + p].load();
	        _SlotEntry=((_SlotEntry<<2)>>2)|(3L << 62);
	        random = INT_MAX;
	        random=((random<<2)>>2)|(3L << 62);
	        Buckets[InitialSlot + p].compare_exchange_strong(_SlotEntry, random);

	    }
	    return rem1 or rem2;

}

protected:
private:
    int ADD_RANGE = 256;//512;
    unsigned int H = 16; //64;
    unsigned int seed;
public:
    std::atomic<unsigned long> substract;
    std::atomic<unsigned long> timeStamp;
    struct timeval start, stop;

};

#endif /* LFHASH_H_ */
